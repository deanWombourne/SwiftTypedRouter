<%
/// Create a parameters type to hold common logic - just to make the templatey bit more readable. That's more readable, not _actually_ readable :)
struct Parameters {
    let types: [String]

    /// i.e. "A, B, C"
    var typesString: String { self.types.joined(separator: ", ") }

    /// typeString with a following comma i.e. "A, B, C, " - or, if we don't have any types, ""
    var initialTypesString: String {
        let typesString = self.typesString
        guard !typesString.isEmpty else { return "" }
        return typesString + ", "
    }

    /// i.e. "<A, B, C>" (or "" if 0 types)
    var genericTypesString: String { self.isEmpty ? "" : "<" + self.typesString + ">" }

    /// i.e. where A: SomeProtocol, B: SomeProtocol
    func geneticWhereCondition(restriction: String) -> String {
        guard !self.isEmpty else { return "" }
        return "where " + self.types.map { $0 + ": " + restriction }.joined(separator: ", ")
    }

    var count: Int { self.types.count }
    var isEmpty: Bool { self.count == 0 }
}

extension Array {

    func mapIfNotEmpty<T>(_ map: @escaping (Element) throws -> T) rethrows -> Array<T> {
        guard !self.isEmpty else { return [] }
        return try self.map(map)
    }
}

extension String {

    func mapIfNotEmpty(_ map: @escaping (String) throws -> String) rethrows -> String {
        guard !self.isEmpty else { return "" }
        return try map(self)
    }
}

let allParameters = [
    [],
    ["A"],
    ["A", "B"],
    ["A", "B", "C"],
    ["A", "B", "C", "D"],
    ["A", "B", "C", "D", "E"],
    ["A", "B", "C", "D", "E", "F"],
    ["A", "B", "C", "D", "E", "F", "G"],
    ["A", "B", "C", "D", "E", "F", "G", "H"],
    ["A", "B", "C", "D", "E", "F", "G", "H", "I"],
    ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"],
].map(Parameters.init)
%>

// sourcery:inline:auto:Router.Add
<% for parameters in allParameters { -%>
    // Generated add method for templates with <%= parameters.count -%> generic types
    public func add<<%=parameters.initialTypesString -%>V: View>(_ template: Template.T<%= parameters.count -%><%= parameters.genericTypesString -%>, action: @escaping (<%= parameters.typesString -%>) -> V) <%= parameters.geneticWhereCondition(restriction: "LosslessStringConvertible") -%> {
        self.routes.append(AnyRoute(template: template, action: action))
    }

    // Generated add method for paths with <%= parameters.count -%> generic types
    public func add<<%=parameters.initialTypesString -%>V: View>(path: String, action: @escaping (<%= parameters.typesString -%>) -> V) <%= parameters.geneticWhereCondition(restriction: "LosslessStringConvertible") -%> {
        self.add(Template.T<%= parameters.count -%>(template: path), action: action)
    }

<% } -%>
// sourcery:end

// sourcery:inline:auto:Router.AnyRoute.Init
<% for parameters in allParameters { -%>
<%
    let argsParameterString = { () -> String in
        guard !parameters.isEmpty else { return "" }
        return ", args: " + parameters.types.map { $0 + ".self" }.joined(separator: ", ")
    }()
    let matchesString = { () -> String in
        switch (parameters.count) {
        case 0: return ""
        case 1: return "matches"
        default: return (0..<parameters.count).map { "matches.\($0)" }.joined(separator: ", ")
        }
    }()
-%>
// Generated init method for templates with <%= parameters.count %> generic types
init<<%= parameters.initialTypesString -%>V: View>(template: Template.T<%= parameters.count -%><%= parameters.genericTypesString -%>, action: @escaping (<%= parameters.typesString -%>) -> V) <%= parameters.geneticWhereCondition(restriction: "LosslessStringConvertible") -%> {
    self.description = Self.createDescription(template: template.template, outputType: V.self<%= argsParameterString -%>)
    self.debugView = Self.createDebugView(template: template.template, outputType: V.self<%= argsParameterString -%>)
    self.matches = { (toMatch: String) in
        guard let matches = template.matcher(toMatch) else { return nil }
        return action(<%= matchesString -%>).eraseToAnyView()
    }
}

<% } -%>
//sourcery:end

// sourcery:inline:auto:Template.Subclasses
<% for parameters in allParameters { -%>
<%
let generics = { () -> String in
    guard !parameters.isEmpty else { return "" }
    return "<" + parameters.types.map { $0 + ": LosslessStringConvertible" }.joined(separator: ", ") + ">"
}()

let lowercaseTypesString = parameters.types.map { $0.lowercased() }.joined(separator: ", ")

let pathMethodParameters = parameters.types
    .map { "_ \($0.lowercased()): \($0)" }
    .joined(separator: ", ")
-%>

// Generated template subclass for templates with <%= parameters.count -%> generic types
public final class T<%= parameters.count -%><%= generics -%>: Template, FactoryTemplate {
    let matcher: (String) -> (<%= parameters.typesString -%>)?

    override public init(template: String) {
        let baseMatcher = Self.createBaseMatcher(path: template)
        self.matcher = {
            guard let matches = baseMatcher($0) else { return nil }
            guard matches.count >= <%= parameters.count -%> else { return nil }
<% for (index, type) in parameters.types.enumerated() { -%>
            guard let <%= type.lowercased() -%> = <%= type -%>(matches[<%= index -%>]) else { return nil }
<% } -%>
            return (<%= lowercaseTypesString -%>)
        }

        super.init(template: template)
    }

    public func path(<%= pathMethodParameters -%>) -> Path {
        createPath(template: self.template<%= lowercaseTypesString.mapIfNotEmpty { ", parameters: " + $0 } -%>)
    }
}
<% } -%>
// sourcery:end

<%
/// Create a parameters typeto hold all the logic - just to make the templatey bit more readable. That's more readable, not _actually_ readable :)
struct Parameters {
    let types: [String]

    /// i.e. "A, B, C"
    var typesString: String { self.types.joined(separator: ", ") }

    /// typeString with a following comma i.e. "A, B, C, " - or, if we don't have any types, ""
    var initialTypesString: String {
        let typesString = self.typesString
        guard !typesString.isEmpty else { return "" }
        return typesString + ", "
    }

    /// i.e. "<A, B, C>" (or "" if 0 types)
    var genericTypesString: String { self.isEmpty ? "" : "<" + self.typesString + ">" }

    /// i.e. where A: SomeProtocol, B: SomeProtocol
    func geneticWhereCondition(restriction: String) -> String {
        guard !self.isEmpty else { return "" }
        return "where " + self.types.map { $0 + ": " + restriction }.joined(separator: ", ")
    }

    var count: Int { self.types.count }
    var isEmpty: Bool { self.count == 0 }
}

let allParameters = [
    [],
    ["A"],
    ["A", "B"],
    ["A", "B", "C"],
    //["A", "B", "C", "D"],
    //["A", "B", "C", "D", "E"]
].map(Parameters.init)
%>

// sourcery:inline:auto:Router.Add
<% for parameters in allParameters { -%>
    public func add<<%=parameters.initialTypesString -%>V: View>(_ template: Template.T<%= parameters.count -%><%= parameters.genericTypesString -%>, action: @escaping (<%= parameters.typesString -%>) -> V) <%= parameters.geneticWhereCondition(restriction: "LosslessStringConvertible") -%> {
        self.routes.append(AnyRoute(template: template, action: action))
    }

    public func add<<%=parameters.initialTypesString -%>V: View>(path: String, action: @escaping (<%= parameters.typesString -%>) -> V) <%= parameters.geneticWhereCondition(restriction: "LosslessStringConvertible") -%> {
        self.add(Template.T<%= parameters.count -%>(template: path), action: action)
    }

<% } -%>
// sourcery:end

// sourcery:inline:auto:Router.AnyRoute.Init
<% for parameters in allParameters { -%>
<%
    let argsParameterString = { () -> String in
        guard !parameters.isEmpty else { return "" }
        return ", args: " + parameters.types.map { $0 + ".self" }.joined(separator: ", ")
    }()
    let matchesString = { () -> String in
        switch (parameters.count) {
        case 0: return ""
        case 1: return "matches"
        default: return (0..<parameters.count).map { "matches.\($0)" }.joined(separator: ", ")
        }
    }()
-%>
// Generated init method for templates with <%= parameters.count %> generic types
init<<%= parameters.initialTypesString -%>V: View>(template: Template.T<%= parameters.count -%><%= parameters.genericTypesString -%>, action: @escaping (<%= parameters.typesString -%>) -> V) <%= parameters.geneticWhereCondition(restriction: "LosslessStringConvertible") -%> {
    self.description = Self.createDescription(template: template.template, outputType: V.self<%= argsParameterString -%>)
    self.debugView = Self.createDebugView(template: template.template, outputType: V.self<%= argsParameterString -%>)
    self.matches = { (toMatch: String) in
        guard let matches = template.matcher(toMatch) else { return nil }
        return action(<%= matchesString -%>).eraseToAnyView()
    }
}

<% } -%>
//sourcery:end
